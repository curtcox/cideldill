# Breakpoint REPL — Plan

## Summary

Allow the user to interact with the app suspended at any breakpoint using a REPL
embedded in the web UI. While the breakpoint is paused, the user can evaluate
arbitrary Python expressions in the context of the paused client process. The
REPL transcript is recorded and linked from the relevant call tree node. Past
sessions are browsable at `/repls` and individually at `/repl/{pid}-{timestamp}`.

## Progress

- [x] Phase 1: Server-side REPL session management (ReplManager in BreakpointManager)
- [ ] Phase 2: Server-side API endpoints
- [ ] Phase 3: Client-side eval support
- [ ] Phase 4: Web UI — REPL session page
- [ ] Phase 5: Web UI — sessions index page
- [ ] Phase 6: Web UI — call stack page
- [ ] Phase 7: Call tree integration
- [ ] Phase 8: Paused execution card integration

---

## Concepts

| Term | Definition |
|------|-----------|
| **REPL session** | An interactive evaluation session tied to one paused breakpoint. Created when the user opens the REPL for a paused execution. Identified by `{pid}-{timestamp}` where `pid` is the client process PID and `timestamp` is the epoch time when the user started the session. |
| **Transcript** | The ordered list of `(input, output)` pairs from a REPL session, stored server-side. |
| **Active session** | A REPL session where the breakpoint is still paused and the user can submit new expressions. |
| **Closed session** | A REPL session where the breakpoint has been resumed. Read-only transcript view. |

---

## Architecture

### Communication Flow

```
Browser (REPL UI)
    │
    │  POST /api/repl/{session_id}/eval   {"expr": "x + 1"}
    │  GET  /api/repl/{session_id}        (poll / transcript)
    │
    ▼
Server (BreakpointServer + ReplManager)
    │
    │  Server queues eval request internally (in-memory queue per pause_id).
    │  Server blocks the browser's POST, waiting for the client to respond.
    │
    │  GET  /api/poll-repl/{pause_id}     (client polls for eval requests)
    │
    ▼
Client (DebugClient, paused in wait_for_resume_action loop)
    │
    │  Receives eval request from poll-repl
    │  Evaluates expression in the paused frame's locals/globals
    │  Serializes result to CID if possible
    │  POST /api/call/repl-result  {
    │      "eval_id": "...",
    │      "pause_id": "...",
    │      "session_id": "...",
    │      "result": "repr string or empty for exec-mode",
    │      "stdout": "captured output",
    │      "error": null,
    │      "result_cid": "abc123..." or null,
    │      "result_data": "base64-encoded bytes or null"
    │  }
    │
    ▼
Server
    │  Appends to transcript (result + stdout + result_cid)
    │  Unblocks the browser's waiting POST, returns result
    ▼
Browser (displays result)
```

### Why the Client Evaluates

The app's runtime state (local variables, imported modules, live objects) lives
in the client process. The server only has serialized snapshots. To provide a
real REPL, expressions must be evaluated in the client process using the actual
stack frame where the breakpoint was hit.

### Client-Side Eval Loop

When a breakpoint pauses, the client enters a dual polling loop (see Dual
Polling Loop below). On each iteration, it polls both `/api/poll/<pause_id>`
for resume actions and `/api/poll-repl/{pause_id}` for REPL eval requests.

When the client receives an eval request from `poll-repl`:

1. The response contains `{"eval_id": "...", "session_id": "...", "expr": "..."}`.
2. Client evaluates `expr` in a background thread (see Eval Threading below).
3. Evaluation uses the frame's `globals` merged with a **session-local namespace
   dict** (lazily created per `session_id`) as `locals`. Assignments via `exec()`
   persist in the session namespace and are visible to subsequent evals in the
   same session.
4. `sys.stdout` and `sys.stderr` are redirected to a `StringIO` during eval.
   Captured output is included in the result alongside the return value.
5. Client POSTs the result (including `eval_id`) to `/api/call/repl-result`.
6. Client continues the dual polling loop (does NOT exit).

The `eval_id` is a unique identifier generated by the server for each eval
request. It correlates the request (from `poll-repl`) with the response (from
`repl-result`), allowing the server to unblock the correct waiting browser POST.

The client stays paused and can handle an arbitrary number of eval requests
before eventually receiving a terminal resume action (`continue`/`skip`/`raise`)
on the other polling channel, which causes the loop to exit.

### Eval Threading and Timeout

Each eval runs in a daemon thread with a default 30-second timeout (configurable
per-server). If the timeout is reached:

- The eval is marked as timed out and an error is returned to the user.
- The thread is abandoned (Python cannot forcibly kill threads). It may continue
  running in the background. This is a known limitation.
- The session remains active for further evals.

The threading approach ensures the client's polling loop is never blocked by a
long-running or infinite eval.

### Eval / Exec Strategy

The client uses `compile(expr, "<repl>", "eval")` first. If that succeeds,
`eval()` is used and the return value is captured. If `compile(..., "eval")`
raises `SyntaxError`, the client falls back to `compile(expr, "<repl>", "exec")`
and uses `exec()`. In the `exec` case there is no return value, but stdout
output and side effects (assignments, imports) are captured.

Multi-line expressions (function definitions, for loops) are supported. The UI
uses a textarea with Shift+Enter for newlines. The user controls when to submit.

When the server receives an expression from the browser, it forwards it to the
client as-is. The client uses `code.compile_command()` (from the standard
library `code` module) to check for completeness. If the input is incomplete
(e.g., `def foo():` with no body), the client returns an error:
`"SyntaxError: incomplete input"` rather than a cryptic compile error. The user
can then add the missing lines and resubmit.

Note: unlike a terminal REPL, the web REPL does NOT do automatic line
continuation. The user composes the full multi-line expression in the textarea
and submits it as one unit.

### Session-Local Namespace

Each REPL session maintains a namespace dict on the client side, keyed by
`session_id`. This dict is passed as the `locals` parameter to `eval()`/`exec()`,
layered on top of the frame's actual locals:

```python
effective_locals = {**frame_locals, **session_namespace}
# After exec(), new names are written back to session_namespace
```

When multiple sessions share the same paused execution (concurrent browser tabs),
each has its own session namespace. Assignments in session A are NOT visible in
session B. However, mutations to shared mutable objects (e.g., `my_list.append(1)`)
ARE visible across sessions since they modify the same underlying objects.

### Stdout/Stderr Capture

During eval, `sys.stdout` and `sys.stderr` are temporarily redirected to
`StringIO` instances. Stderr is merged with stdout in the captured output.

**What the client sends** (data model, not display logic):

- `result` field: For eval mode, `repr(return_value)`. For exec mode, empty
  string `""` (exec has no return value). For errors, empty string.
- `stdout` field: All captured stdout/stderr output. May be empty string.
- `error` field: Error message string, or `null` if no error.

**How the server stores it** in the transcript:

- `output` = `error` if error is not null, else `result`. (Server renames
  `result`/`error` → `output`/`is_error`.)
- `stdout` = `stdout` from client (stored as-is).
- `is_error` = `true` if `error` was not null.

**How the UI displays it:**

- If `is_error`: show `output` in error styling.
- Else if `output` is non-empty and `stdout` is non-empty: show both
  (stdout first, then `>>> result`).
- Else if `output` is non-empty: show `output` (eval result).
- Else if `stdout` is non-empty: show `stdout` (exec with print).
- Else: show nothing (pure exec like `x = 42` with no output).

### In-Flight Eval on Breakpoint Resume

When a breakpoint resumes while an eval is in flight:

1. The server auto-closes all REPL sessions for the pause_id.
2. The browser's blocking `/api/repl/{session_id}/eval` POST returns a 409
   ("session closed") immediately.
3. On the client, the eval thread is abandoned (may still be running, but its
   result will be discarded).
4. The client's POST to `/api/call/repl-result` for the abandoned eval gets a
   409 response, which the client silently ignores.
5. The result is NOT appended to the transcript.

### CID Serialization of Eval Results

The **client** serializes eval results to CIDs, since the live Python object
exists only in the client process. The flow:

1. Client evaluates the expression, gets a Python object.
2. Client calls `repr()` for the transcript display string.
3. Client attempts to serialize the object via dill (same as existing call
   result serialization). If successful, produces a CID and base64-encoded
   serialized bytes.
4. Client includes both `result_cid` and `result_data` (base64-encoded bytes)
   in the `/api/call/repl-result` POST. This matches the existing pattern
   used by `call_complete` which sends both `result_cid` and `result_data`.
5. Server stores the serialized data in the CAS store keyed by `result_cid`,
   and records `result_cid` in the transcript entry.
6. If serialization fails (unpicklable object), both `result_cid` and
   `result_data` are `null`. This is not an error — the `repr()` string
   is always available for display.

### Dual Polling Loop

The client polls two endpoints concurrently while paused:

1. **`/api/poll/<pause_id>`** — existing endpoint for resume actions. When a
   terminal action (`continue`, `skip`, `raise`, `modify`) is received, the
   client exits the loop and resumes execution.

2. **`/api/poll-repl/{pause_id}`** — new endpoint for REPL eval requests. When
   an eval request is received, the client handles it (in a background thread)
   and posts the result back, but does NOT exit the loop.

Implementation: the existing `wait_for_resume_action` loop is extended to
alternate between polling both endpoints on each iteration (or poll both in
parallel using threads). The loop returns only when a terminal resume action is
received. REPL eval requests are handled as side effects within the loop.

When the breakpoint resumes (terminal action received):
- Any in-flight eval thread is abandoned (result discarded if it completes later).
- The server auto-closes all REPL sessions for this pause_id.
- The client's repl-result POST for an abandoned eval gets a 409 response
  (session already closed), which the client silently ignores.

---

## Data Model

### ReplSession (server-side, in ReplManager)

```python
{
    "session_id": str,           # "{pid}-{timestamp}" — unique identifier
    "pause_id": str,             # Links to paused execution in BreakpointManager
    "pid": int,                  # Client process PID
    "started_at": float,         # Epoch timestamp when user started session
    "closed_at": float | None,   # Epoch timestamp when breakpoint resumed (None if active)
    "function_name": str,        # The function where the breakpoint was hit
    "call_id": str | None,       # Links to call record for call tree integration
    "process_key": str,          # "{pid}_{start_time}" for call tree linkage
    "transcript": [              # Ordered list of interactions
        {
            "index": int,
            "input": str,        # User expression
            "output": str,       # repr() of result or error message
            "stdout": str,       # Captured stdout/stderr output (may be empty)
            "is_error": bool,
            "result_cid": str | None,  # CID of serialized result (None if serialization failed)
            "timestamp": float,  # When this exchange happened
        },
    ],
}
```

### Storage

REPL sessions are stored in `BreakpointManager` (in-memory dict keyed by
`session_id`). Sessions do NOT survive server restarts — this is consistent
with how paused executions and call records are stored today, and active
sessions become invalid on restart since the client breakpoint is also lost.
SQLite persistence for historical transcripts could be added later if needed.

Eval results are stored as `repr()` strings in the transcript for display.
Additionally, results are serialized to CIDs in the CAS store when
serialization succeeds (graceful degradation). This allows deep inspection
via the object browser for results that can be pickled.

---

## Routes

### Pages (HTML)

| Route | Purpose |
|-------|---------|
| `/repls` | Searchable/filterable timestamp-based index of all REPL sessions. |
| `/repl/{pid}-{timestamp}` | Dedicated page for one REPL session. Active: shows live REPL. Closed: shows transcript. |
| `/callstack/{pause_id}` | Complete call stack information for the breakpoint associated with a pause. |

### API Endpoints

**Browser-facing endpoints:**

| Route | Method | Purpose |
|-------|--------|---------|
| `/api/repl/start` | POST | Start a new REPL session for a paused execution. Body: `{"pause_id": "..."}`. Returns `{"session_id": "..."}`. |
| `/api/repl/{session_id}` | GET | Get session metadata + full transcript. |
| `/api/repl/{session_id}/eval` | POST | Submit an expression. Body: `{"expr": "..."}`. **Blocks** until client evaluates and posts result (or timeout). Returns `{"output": "...", "stdout": "...", "is_error": false, "result_cid": "..."}`. |
| `/api/repl/sessions` | GET | List all sessions. Query params: `?search=`, `?status=active|closed`, `?from=`, `?to=`. |
| `/api/repl/{session_id}/close` | POST | Explicitly close a session (marks closed_at). Also happens automatically when breakpoint resumes. |

**Client-facing endpoints:**

| Route | Method | Purpose |
|-------|--------|---------|
| `/api/poll-repl/{pause_id}` | GET | Client polls for pending eval requests. Returns `{"eval_id": "...", "session_id": "...", "expr": "..."}` or `{"eval_id": null}` if none pending. |
| `/api/call/repl-result` | POST | Client posts eval result. Body: `{"eval_id": "...", "pause_id": "...", "session_id": "...", "result": "repr or empty", "stdout": "captured output", "error": "msg or null", "result_cid": "cid or null", "result_data": "base64 bytes or null"}`. |

Eval request queuing is internal to the server (in-memory queue per pause_id),
not a separate HTTP endpoint.

### Call Tree Integration

Each call tree node for a paused execution that had REPL sessions will include
links to the associated `/repl/{pid}-{timestamp}` pages. The call record in
`BreakpointManager._call_records` will gain a `repl_sessions` field: a list of
`session_id` values.

---

## UI Design

### `/repls` — Session Index Page

- Header: "REPL Sessions"
- Search bar: free-text search across function names and transcript content.
- Filters:
  - Status: All / Active / Closed (radio buttons or dropdown).
  - Date range: From / To timestamp pickers.
- Table columns:
  - Session ID (link to `/repl/{pid}-{timestamp}`)
  - Function name
  - Status (Active / Closed badge)
  - Started at (human-readable timestamp)
  - Closed at (or "—" if active)
  - Transcript lines count
  - Call stack link (link to `/callstack/{pause_id}`)
- Sorted by `started_at` descending (most recent first).
- Pagination if session count exceeds a threshold (e.g., 50 per page).

### `/repl/{pid}-{timestamp}` — Session Page

**Header section:**
- Function name and breakpoint details.
- Status badge (Active / Closed).
- Link to `/callstack/{pause_id}` ("View Call Stack").
- Link to `/call-tree/{process_key}` ("View Call Tree").
- Timestamps (started, closed).

**Transcript section:**
- Scrollable area showing all past `input`/`output` pairs.
- Inputs styled as `>>>` prompts (monospace, syntax highlighted).
- Outputs styled as REPL output (monospace).
- Errors styled distinctly (red text or red border).
- Auto-scrolls to bottom on new entries.

**Input section (active sessions only):**
- Text input (or multi-line textarea with shift+enter for newlines).
- Submit button / Enter to evaluate.
- Disabled with message "Breakpoint resumed — session closed" when closed.

**Callstack link:**
- Prominent link/button: "View Call Stack" → `/callstack/{pause_id}`.

### `/callstack/{pause_id}` — Call Stack Page

Shows the call stack **at the moment the breakpoint was hit** (the stack trace
already captured in the paused execution's `call_site.stack_trace`). The stack
is static — it does not change while paused.

- Header: "Call Stack for {function_name}"
- Link back to REPL session(s) associated with this pause.
- Full stack trace display (reuse existing frame view pattern from `/frame/`):
  - Each frame shows: filename, line number, function name, code context.
  - Frames are clickable to expand/collapse source context.
- Does NOT show local variable values (use the REPL to inspect variables).
  Local variables display can be added as a follow-up if needed.
- Link to the call tree node.

### Call Tree Node Integration

On the `/call-tree/{process_key}` page, call tree nodes that have associated
REPL sessions will show a small "REPL" badge/link. Clicking it navigates to the
relevant `/repl/{pid}-{timestamp}` page. If multiple REPL sessions exist for
one call, all are listed.

---

## Implementation Plan

### Phase 1: Server-Side REPL Session Management

1. Create `ReplManager` class (or extend `BreakpointManager`):
   - `start_session(pause_id) -> session_id`
   - `get_session(session_id) -> ReplSession`
   - `list_sessions(search, status, from_ts, to_ts) -> list[ReplSession]`
   - `append_transcript(session_id, input, output, stdout, is_error, result_cid=None) -> int`
     (`index` and `timestamp` are auto-generated)
   - `close_session(session_id)`
   - `get_sessions_for_pause(pause_id) -> list[session_id]`
   - `get_sessions_for_call(call_id) -> list[session_id]`
2. Thread-safe with locking (same pattern as `BreakpointManager`).
3. Auto-close sessions when breakpoint resumes (hook into `resume_execution`).

### Phase 2: Server-Side API Endpoints

1. Add REPL API routes to `BreakpointServer._register_routes()`.
2. Implement eval request queuing:
   - When browser POSTs to `/api/repl/{session_id}/eval`, server creates an
     eval request and queues it for the client.
   - Server blocks (with timeout) waiting for the client to post the result.
3. Implement client-facing endpoints:
   - `/api/poll-repl/{pause_id}` — client polls for eval requests.
   - `/api/call/repl-result` — client posts eval results.

### Phase 3: Client-Side Eval Support

1. Modify `wait_for_resume_action` loop in client to also poll
   `/api/poll-repl/{pause_id}` for eval requests.
2. Implement session-local namespace management:
   - Dict per session_id, keyed by session_id, stored on the client.
   - Merged with frame locals/globals for each eval call.
   - Assignments persist in the session namespace across evals.
3. Implement eval execution:
   - Use `code.compile_command()` first to detect incomplete input (return
     `"SyntaxError: incomplete input"` error to user).
   - If complete, try `compile(expr, "<repl>", "eval")` first, fall back to
     `compile(expr, "<repl>", "exec")` mode.
   - Run eval/exec in a daemon thread with 30s timeout (configurable).
   - Redirect `sys.stdout`/`sys.stderr` to `StringIO` during eval.
   - Serialize result to CID + base64 data via dill (graceful degradation
     if unpicklable — send null for both result_cid and result_data).
   - POST eval_id + result + stdout + error + result_cid + result_data to
     `/api/call/repl-result`.
4. Continue polling — do NOT resume execution until a terminal action arrives.

### Phase 4: Web UI — REPL Session Page

1. Create HTML template for `/repl/{pid}-{timestamp}`.
2. JavaScript for:
   - Submitting expressions via fetch POST to `/api/repl/{session_id}/eval`.
     The POST blocks until the result is ready, so no separate result polling
     is needed for the submitter.
   - Periodic polling of `/api/repl/{session_id}` for transcript updates (needed
     when viewing the same session from a second browser tab, or to detect
     session closure from breakpoint resume).
   - Rendering transcript entries.
   - Auto-scroll behavior.
   - Input history (up/down arrow).
3. Syntax highlighting for Python expressions (reuse Pygments integration).

### Phase 5: Web UI — Sessions Index Page

1. Create HTML template for `/repls`.
2. JavaScript for:
   - Search/filter controls.
   - Fetch session list from `/api/repl/sessions`.
   - Pagination.

### Phase 6: Web UI — Call Stack Page

1. Create HTML template for `/callstack/{pause_id}`.
2. Reuse frame rendering logic from existing `/frame/` route.
3. Add links to associated REPL sessions.

### Phase 7: Call Tree Integration

1. Add `repl_sessions` field to call records.
2. Modify call tree HTML template to show REPL links on nodes with sessions.

### Phase 8: Paused Execution Card Integration

1. Add "Open REPL" button to the paused execution cards on the main page.
2. Clicking it POSTs to `/api/repl/start` and redirects to the session page.

---

## Tests

### Unit Tests — ReplManager

```
test_start_session_creates_session_with_correct_fields
test_start_session_returns_unique_session_id_format
test_start_session_for_nonexistent_pause_id_raises_error
test_start_session_session_id_contains_pid_and_timestamp
test_get_session_returns_correct_session
test_get_session_nonexistent_returns_none
test_list_sessions_returns_all_sessions
test_list_sessions_filter_by_active_status
test_list_sessions_filter_by_closed_status
test_list_sessions_filter_by_timestamp_range
test_list_sessions_search_by_function_name
test_list_sessions_search_by_transcript_content
test_list_sessions_combined_filters
test_list_sessions_empty_when_no_sessions
test_append_transcript_adds_entry_with_correct_fields
test_append_transcript_entries_ordered_by_index
test_append_transcript_to_nonexistent_session_raises_error
test_append_transcript_to_closed_session_raises_error
test_close_session_sets_closed_at
test_close_session_already_closed_is_idempotent
test_close_session_nonexistent_raises_error
test_auto_close_on_breakpoint_resume
test_get_sessions_for_pause_returns_matching_sessions
test_get_sessions_for_pause_returns_empty_for_no_sessions
test_get_sessions_for_call_returns_matching_sessions
test_thread_safety_concurrent_session_starts
test_thread_safety_concurrent_transcript_appends
test_multiple_sessions_for_same_pause_id
```

### Unit Tests — API Endpoints (Server)

```
test_post_repl_start_creates_session_returns_session_id
test_post_repl_start_missing_pause_id_returns_400
test_post_repl_start_invalid_pause_id_returns_404
test_post_repl_start_pause_already_resumed_returns_409
test_get_repl_session_returns_metadata_and_transcript
test_get_repl_session_nonexistent_returns_404
test_post_repl_eval_queues_expression_and_returns_result
test_post_repl_eval_missing_expr_returns_400
test_post_repl_eval_empty_expr_returns_400
test_post_repl_eval_on_closed_session_returns_409
test_post_repl_eval_timeout_when_client_disconnected_returns_504
test_get_repl_sessions_returns_all_sessions
test_get_repl_sessions_filter_by_status
test_get_repl_sessions_filter_by_timestamp_range
test_get_repl_sessions_search_parameter
test_get_repl_sessions_pagination
test_post_repl_close_closes_session
test_post_repl_close_nonexistent_returns_404
test_poll_repl_returns_pending_eval_request_with_eval_id
test_poll_repl_returns_null_eval_id_when_no_requests
test_call_repl_result_posts_result_with_stdout_and_cid
test_call_repl_result_includes_result_data_base64
test_call_repl_result_posts_error_back
test_call_repl_result_maps_error_to_output_and_is_error
test_call_repl_result_maps_result_to_output_when_no_error
test_call_repl_result_unblocks_waiting_eval_request
test_call_repl_result_for_closed_session_returns_409
test_post_repl_eval_blocks_until_client_responds
test_post_repl_eval_returns_stdout_and_result_cid
```

### Unit Tests — Client-Side Eval

```
test_eval_simple_expression_returns_result
test_eval_expression_with_local_variables
test_eval_expression_with_global_variables
test_eval_expression_referencing_function_arguments
test_eval_syntax_error_returns_error
test_eval_runtime_error_returns_error_with_traceback
test_eval_name_error_returns_helpful_message
test_eval_statement_via_exec_fallback
test_eval_import_statement
test_eval_assignment_then_reference_in_later_eval
test_eval_modifying_local_variable
test_eval_accessing_self_on_method_breakpoint
test_eval_result_repr_for_large_objects_is_truncated
test_eval_result_repr_for_unprintable_objects
test_eval_does_not_resume_execution
test_eval_multiple_expressions_sequentially
test_client_polls_repl_eval_requests
test_client_posts_repl_result_after_eval
test_client_continues_polling_after_eval
test_client_resumes_only_on_terminal_action
test_client_handles_eval_during_polling_loop
test_client_dual_polls_resume_and_repl_endpoints
test_client_resume_action_exits_loop_despite_pending_eval
test_client_ignores_409_from_repl_result_after_resume
test_eval_with_multiline_expression
test_eval_timeout_protection_for_infinite_loops
```

### Unit Tests — Session Namespace

```
test_namespace_assignment_persists_across_evals
test_namespace_import_persists_across_evals
test_namespace_overlays_frame_locals
test_namespace_does_not_shadow_frame_locals_initially
test_namespace_assignment_shadows_frame_local_in_later_eval
test_namespace_isolated_between_sessions_on_same_pause
test_namespace_mutation_of_shared_mutable_object_visible_across_sessions
test_namespace_cleared_when_session_closes
test_namespace_function_definition_via_exec_callable_in_later_eval
test_namespace_class_definition_via_exec_usable_in_later_eval
test_namespace_del_variable_removes_from_namespace
```

### Unit Tests — Stdout/Stderr Capture

```
test_eval_print_captured_in_stdout_field
test_eval_stderr_captured_in_stdout_field
test_eval_print_plus_return_value_both_in_result
test_eval_print_only_no_return_value
test_eval_return_value_only_no_stdout
test_eval_exec_no_stdout_no_return_value_shows_empty
test_eval_multiline_stdout_captured_completely
test_eval_stdout_redirect_restored_after_eval
test_eval_stdout_redirect_restored_after_exception
test_eval_nested_print_in_function_call_captured
test_eval_exec_mode_result_is_empty_string
test_eval_mode_result_is_repr_of_return_value
test_eval_expression_returning_none_result_is_none_string
```

### Unit Tests — Eval Threading and Timeout

```
test_eval_runs_in_background_thread
test_eval_timeout_returns_error_message
test_eval_timeout_does_not_block_polling_loop
test_eval_timeout_session_remains_active_after_timeout
test_eval_timeout_configurable_per_server
test_eval_fast_expression_completes_before_timeout
test_eval_abandoned_thread_does_not_crash_client
test_eval_concurrent_request_waits_for_previous
```

### Unit Tests — Multi-line Input

```
test_multiline_function_definition_and_call
test_multiline_for_loop
test_multiline_if_else
test_multiline_class_definition
test_multiline_try_except
test_multiline_with_statement
test_compile_command_detects_incomplete_input
test_compile_command_detects_complete_input
test_incomplete_input_returns_syntax_error_message
test_incomplete_def_without_body_returns_incomplete_error
test_incomplete_for_without_body_returns_incomplete_error
test_single_line_still_works
```

### Unit Tests — Result CID Storage

```
test_eval_result_stored_as_cid_when_serializable
test_eval_result_cid_none_when_not_serializable
test_eval_result_cid_viewable_in_object_browser
test_eval_error_result_has_no_cid
test_transcript_entry_includes_result_cid_field
```

### Unit Tests — Call Stack Page

```
test_callstack_page_renders_for_valid_pause_id
test_callstack_page_returns_404_for_invalid_pause_id
test_callstack_page_shows_all_stack_frames
test_callstack_page_shows_frame_filenames_and_line_numbers
test_callstack_page_shows_code_context
test_callstack_page_links_to_repl_sessions
test_callstack_page_links_to_call_tree
```

### Unit Tests — REPL Session Page

```
test_repl_page_renders_for_active_session
test_repl_page_renders_for_closed_session
test_repl_page_shows_transcript
test_repl_page_shows_input_field_when_active
test_repl_page_hides_input_field_when_closed
test_repl_page_shows_closed_message_when_closed
test_repl_page_returns_404_for_nonexistent_session
test_repl_page_links_to_callstack
test_repl_page_links_to_call_tree
```

### Unit Tests — Sessions Index Page

```
test_repls_page_renders_with_no_sessions
test_repls_page_renders_with_sessions
test_repls_page_shows_session_links
test_repls_page_search_filters_by_function_name
test_repls_page_search_filters_by_transcript_content
test_repls_page_filter_by_active_status
test_repls_page_filter_by_closed_status
test_repls_page_filter_by_date_range
test_repls_page_sorted_by_most_recent_first
test_repls_page_pagination
test_repls_page_shows_callstack_links
```

### Unit Tests — Call Tree Integration

```
test_call_tree_node_shows_repl_badge_when_session_exists
test_call_tree_node_no_repl_badge_when_no_session
test_call_tree_node_repl_badge_links_to_session_page
test_call_tree_node_multiple_sessions_shows_all_links
test_call_record_repl_sessions_field_populated_on_session_start
test_call_record_repl_sessions_field_empty_by_default
```

### Unit Tests — Paused Execution Card

```
test_paused_card_shows_open_repl_button
test_paused_card_repl_button_starts_session_and_redirects
test_paused_card_shows_existing_repl_link_if_session_active
```

### Integration Tests

```
test_full_repl_flow_start_eval_close
    Start server, pause a breakpoint, start REPL session, eval expression,
    verify result in transcript, resume breakpoint, verify session closed.

test_repl_eval_accesses_live_client_state
    Breakpoint pauses with known local variables. REPL eval reads them
    correctly.

test_repl_eval_modifies_client_state
    Eval an assignment, then eval a read of that variable in the same session.
    Verify the modification persisted.

test_repl_session_closes_on_breakpoint_resume
    Start REPL, resume breakpoint from UI (not from REPL), verify session
    auto-closes and transcript is preserved.

test_repl_eval_after_resume_returns_error
    Resume breakpoint, then try to eval. Verify 409 response.

test_multiple_repl_sessions_same_breakpoint
    Start two REPL sessions for the same paused execution. Both work
    independently. Both appear in call tree node.

test_repl_transcript_persists_after_close
    Close session, GET transcript, verify all entries present.

test_repl_session_visible_in_call_tree
    Start REPL for a paused call, verify call tree shows REPL link.

test_repls_index_lists_all_sessions
    Create multiple sessions, verify /repls lists them all.

test_repls_index_search_works
    Create sessions for different functions, search by function name.

test_repl_page_live_interaction
    Open /repl/{pid}-{timestamp} for active session, submit expression via
    form, verify result appears in transcript.

test_repl_page_shows_read_only_transcript_when_closed
    Close session, load page, verify no input field, transcript visible.

test_callstack_page_complete_stack_info
    Pause at breakpoint, verify /callstack/{pause_id} shows full stack.

test_repl_page_links_to_callstack
    Verify /repl/{pid}-{timestamp} page has working link to /callstack/.

test_client_disconnect_during_eval_times_out_gracefully
    Start eval, kill client process, verify server returns timeout error
    and session can be closed.

test_concurrent_evals_serialized
    Submit two evals rapidly. Verify they execute sequentially and both
    results appear in transcript in order.
```

### Edge Case Tests

```
test_eval_expression_that_raises_exception
test_eval_expression_that_returns_none
test_eval_expression_that_returns_empty_string
test_eval_expression_that_returns_very_large_result
test_eval_expression_with_unicode
test_eval_expression_with_special_characters
test_eval_expression_that_blocks_indefinitely_times_out
test_eval_expression_that_prints_to_stdout
test_eval_expression_that_modifies_mutable_argument
test_session_id_with_large_pid
test_session_id_with_high_precision_timestamp
test_start_session_race_condition_same_pid_timestamp
test_start_session_collision_retries_with_1ms_bump
test_close_session_while_eval_in_flight
test_resume_breakpoint_while_eval_in_flight
test_server_restart_loses_in_memory_sessions
test_multiple_clients_same_pid_different_start_time
test_repl_session_for_inline_breakpoint_vs_proxy_breakpoint
test_repl_with_async_debug_call_breakpoint
test_repls_page_with_hundreds_of_sessions_performance
test_transcript_with_hundreds_of_entries_performance
test_eval_in_nested_breakpoint_scope
test_callstack_page_for_deeply_nested_stack
test_start_repl_on_already_resumed_breakpoint_returns_409
test_stdout_redirect_thread_safety_during_concurrent_eval
test_eval_expression_that_modifies_sys_stdout_directly
test_eval_expression_that_spawns_threads
test_abandoned_timeout_thread_eventual_completion
test_session_namespace_not_leaked_to_other_sessions
test_eval_result_cid_graceful_degradation_unpicklable
test_concurrent_sessions_interleaved_evals_correct_transcripts
```

---

## Resolved Decisions

1. **Exec vs Eval scope isolation**: Yes. Maintain a session-local namespace
   dict per session that is passed as the `locals` parameter to both `eval()`
   and `exec()`, merged with the frame's actual locals. Assignments persist
   across evals within the same session.

2. **Stdout/stderr capture**: Yes. Redirect `sys.stdout` and `sys.stderr` to
   `StringIO` during eval. Include captured output in the result. If there is
   both a return value and stdout output, show both.

3. **Security**: Yes. The REPL has full access to the client process. Same
   trust model as pdb/gdb. Document this.

4. **Timeout for eval**: Default 30 seconds, configurable per-server. Client
   runs eval in a daemon thread so the polling loop is never blocked. On
   timeout, the eval is abandoned (thread cannot be killed — known limitation)
   and an error is returned to the user.

5. **Multi-line input**: Yes. UI textarea supports Shift+Enter for newlines.
   Client uses `code.compile_command()` for incomplete input detection.

6. **Persistence**: No. Sessions are in-memory only. Active sessions become
   invalid on server restart (client breakpoint is also lost). SQLite
   persistence for historical transcripts can be added later.

7. **REPL for already-resumed breakpoints**: No. The REPL requires a live
   paused execution. Past breakpoints are viewable only through their existing
   execution history pages.

8. **Eval result serialization**: Store `repr()` in the transcript for display.
   Also store serialized result as a CID in the CAS store when serialization
   succeeds (graceful degradation). Failed serialization is silently skipped.

9. **Concurrent sessions on same pause**: Yes, allowed. Each session has its
   own transcript and its own session-local namespace dict. Mutations to shared
   mutable objects (e.g., `my_list.append(1)`) are visible across sessions
   since they modify the same underlying objects in the frame.

10. **Call stack local variables**: Start without local variables in the
    callstack page (frame metadata only, matching existing `/frame/` route).
    The REPL is the primary way to inspect variables. Locals display can be
    added as a follow-up.

11. **Callstack shows static snapshot**: The `/callstack/{pause_id}` page shows
    the call stack at the moment the breakpoint was hit. This is the stack trace
    already captured in `call_site.stack_trace`. Static, not live.

12. **Session ID uniqueness**: Use microsecond-precision timestamps
    (`time.time()` float). Add check-and-retry with 1ms bump if collision
    detected.

## Open Questions

None. All questions have been resolved.
